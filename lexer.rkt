(module lexer racket

  (require parser-tools/lex
           (prefix-in : parser-tools/lex-sre))

  (provide (all-defined-out))
  
  (define simple-python-lexer
    (lexer
     ((eof) (token-EOF))
     (";" (token-semicolon))
     ("pass" (token-pass))
     ("break" (token-break))
     ("continue" (token-continue))
     ("equal" (token-equal-sign))
     ("return" (token-return))
     ("global" (token-global))
     ("def" (token-def))
     ("(" (token-lpar))
     (")" (token-rpar))
     (":" (token-colon))
     ("():" (token-empty-params))
     ("," (token-comma))
     ("if" (token-if))
     ("else" (token-else))
     ("for" (token-for))
     ("in" (token-in))
     ("or" (token-or))
     ("and" (token-and))
     ("not" (token-not))
     ("=" (token-equal-sign))
     ("==" (token-eq))
     ("<" (token-lt))
     (">" (token-gt))
     ("+" (token-plus))
     ("-" (token-minus))
     ("*" (token-multiply))
     ("/" (token-divide))
     ("**" (token-power))
     ("[" (token-lbra))
     ("]" (token-rbra))
     ("()" (token-empty-args))
     ("True" (token-true))
     ("False" (token-false))
     ("None" (token-none))
     ("print" (token-print))
     ("[]" (token-empty-list))
     ((:or (:+ (char-range #\0 #\9))
           (:: (:+ (char-range #\0 #\9)) #\. (:+ (char-range #\0 #\9))))
      (token-NUMBER (string->number lexeme)))
     ((:: (:+ (:or #\_ (char-range #\a #\z) (char-range #\A #\Z))) (:* (:or #\_ (char-range #\0 #\9) (char-range #\a #\z) (char-range #\A #\Z))))
      (token-ID lexeme))
     (whitespace (simple-python-lexer input-port))))

  (define-tokens a (NUMBER ID))
  (define-empty-tokens b (EOF semicolon pass break continue equal-sign return global def rpar lpar colon empty-params comma if else for in or and not eq lt gt plus minus multiply divide power lbra rbra empty-args true false none empty-list print))
  
  )